#ifndef LARGE_SOURCE_COMPUTE_HPP
#define LARGE_SOURCE_COMPUTE_HPP

/*
 * large_source_compute.hpp
 *
 * Copyright (c) 2018 mugwort_rc.
 *
 * License:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <cassert>
#include <chrono>
#include <fstream>
#include <type_traits>
#include <utility>
#include <vector>

#include <boost/compute.hpp>


namespace sep {

namespace compute {

namespace source {

template <class T, typename Scalar>
class interface {
public:
    interface() {
        // implement required std::size_t T::read_bytes(char *, std::size_t)
        static_assert(
            std::is_same<
                decltype(std::declval<T>().read_bytes(
                    std::declval<char *>(),
                    std::declval<std::size_t>()
                )),
                std::size_t>::value,
            "std::size_t T::read_bytes(char *, std::size_t) is not defined."
        );
        // implement required std::size_t T::total_bytes() const
        static_assert(
            std::is_same<
                decltype(std::declval<T>().total_bytes()),
                std::size_t>::value,
            "std::size_t T::total_bytes(char *, std::size_t) is not defined."
        );
        // implement required std::size_t T::remain_bytes()
        static_assert(
            std::is_same<
                decltype(std::declval<T>().remain_bytes()),
                std::size_t>::value,
            "std::size_t T::remain_bytes(char *, std::size_t) is not defined."
        );
    }

    virtual ~interface()
    {}

    typedef Scalar type;
    static constexpr std::size_t type_bytes = sizeof(type);

    virtual bool is_valid_type() const {
        if ( this->excess_bytes() > 0 ) {
            return false;
        }
        return true;
    }

    std::size_t read(std::vector<Scalar> &src) {
        return this->read(src, src.size());
    }

    std::size_t read(std::vector<Scalar> &src, std::size_t size) {
        std::size_t bytes = size * this->type_bytes;
        std::size_t read = this->read_bytes(reinterpret_cast<char *>(&src[0]), bytes);
        if ( read == bytes ) {
            return size;
        }
        assert(size < bytes);
        return size / this->type_bytes;
    }

    std::size_t total() const {
        return this->total_bytes() / this->type_bytes;
    }

    std::size_t remain() {
        return this->remain_bytes() / this->type_bytes;
    }

    std::size_t excess_bytes() const {
        return this->total_bytes() % this->type_bytes;
    }

public:
    std::size_t read_bytes(char *memory, std::size_t size) {
        return static_cast<T *>(this)->read_bytes(memory, size);
    }
    std::size_t total_bytes() const {
        return static_cast<const T *>(this)->total_bytes();
    }
    std::size_t remain_bytes() {
        return static_cast<T *>(this)->remain_bytes();
    }

};


namespace stdcpp {

template <typename Scalar>
class file : public interface<file<Scalar>, Scalar>
{
public:
    file(const std::string &filepath) :
        interface<file, Scalar>(),
        ifs(filepath, std::ios::binary),
        _total_bytes(0)
    {
        this->ifs.seekg(0, ifs.end);
        this->_total_bytes = ifs.tellg();
        this->ifs.seekg(0, ifs.beg);
    }

    operator bool() {
        return ! this->ifs.eof();
    }

public:
    // implement of interface abstract methods
    std::size_t read_bytes(char *memory, std::size_t size) {
        if ( this->ifs.eof() ) {
            return 0;
        }
        std::streamoff before = this->ifs.tellg();
        this->ifs.read(memory, size);
        if ( this->ifs.eof() ) {
            return this->_total_bytes - before;
        }
        return this->ifs.tellg() - before;
    }

    std::size_t total_bytes() const {
        return this->_total_bytes;
    }

    std::size_t remain_bytes() {
        if ( this->ifs.eof() ) {
            return 0;
        }
        return this->_total_bytes - this->ifs.tellg();
    }

    std::ifstream ifs;
    std::size_t _total_bytes;

};

} // namespace stdcpp

using stdcpp::file;

} // namespace source

namespace sink {

template <class T, typename Scalar>
class interface {
public:
    interface() {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().write_bytes(
                    std::declval<char *>(),
                    std::declval<std::size_t>()
                )),
                std::size_t>::value,
            "std::size_t T::write_bytes(char *, std::size_t) is not defined."
        );
    }

    virtual ~interface()
    {}

    typedef Scalar type;
    static constexpr std::size_t type_bytes = sizeof(type);

    std::size_t write(const std::vector<Scalar> &src) {
        return this->write(src, src.size());
    }

    std::size_t write(const std::vector<Scalar> &src, std::size_t size) {
        if ( size == 0 ) {
            return 0;
        }
        std::size_t bytes = size * this->type_bytes;
        std::size_t wrote = this->write_bytes(const_cast<char *>(reinterpret_cast<const char *>(&src[0])), bytes);
        return wrote / this->type_bytes;
    }

public:
    std::size_t write_bytes(char *memory, std::size_t size) {
        return static_cast<T *>(this)->write_bytes(memory, size);
    }

};


namespace stdcpp {

template <typename Scalar>
class file : public interface<file<Scalar>, Scalar>
{
public:
    file(const std::string &filepath) :
        interface<file, Scalar>(),
        ofs(filepath, std::ios::binary)
    {}

    operator bool() {
        return static_cast<bool>(this->ofs);
    }

public:
    // implement of interface abstract method
    std::size_t write_bytes(char *memory, std::size_t size) {
        if ( ! this->ofs ) {
            return 0;
        }
        std::streamoff before = this->ofs.tellp();
        this->ofs.write(memory, size);
        return this->ofs.tellp() - before;
    }

    std::ofstream ofs;

};

} // namespace stdcpp

using stdcpp::file;

} // namespace sink


namespace utility {

namespace time {

class measure {
public:

    class context {
    public:
        context(measure *m) :
            m(m),
            created_at(std::chrono::system_clock::now())
        {}

        ~context() {
            this->done();
        }

        void done() {
            if ( this->m == nullptr ) {
                return;
            }
            auto now = std::chrono::system_clock::now();
            auto delta = now - this->created_at;
            this->m->time += std::chrono::duration_cast<std::chrono::microseconds>(delta).count();
            this->m = nullptr;
        }

    protected:
        measure *m;
        std::chrono::system_clock::time_point created_at;

    };

    measure() :
        time(0)
    {}

    measure(const measure &) = delete;
    measure &operator =(const measure &) = delete;

    context create_context() {
        return context(this);
    }

    std::size_t time;
};

} // namespace time


class callback {
public:
    virtual ~callback() {}

    virtual void initialize(std::size_t total, std::size_t count) = 0;
    virtual void finalize() = 0;

    virtual void pre_compute(std::size_t block) = 0;
    virtual void post_compute(std::size_t block) = 0;

    virtual void pre_host_to_device(std::size_t block) = 0;
    virtual void post_host_to_device(std::size_t block) = 0;

    virtual void pre_device_to_host(std::size_t block) = 0;
    virtual void post_device_to_host(std::size_t block) = 0;

};

inline void initialize_callback(callback *cb, std::size_t total, std::size_t block) {
    if ( cb == nullptr ) {
        return;
    }
    cb->initialize(total, block);
}

inline void finalize_callback(callback *cb) {
    if ( cb == nullptr ) {
        return;
    }
    cb->finalize();
}

template <class T, class... Args>
inline void compute_with_callback(T *self, std::size_t block, callback *cb, Args &... args) {
    if ( cb ) {
        cb->pre_compute(block);
    }
    self->do_compute(args...);
    if ( cb ) {
        cb->post_compute(block);
    }
}

template <class T, class... Args>
inline void host_to_device_with_callback(T *self, std::size_t block, callback *cb, Args &... args) {
    if ( cb ) {
        cb->pre_host_to_device(block);
    }
    self->host_to_device(args...);
    if ( cb ) {
        cb->post_host_to_device(block);
    }
}

template <class T, class... Args>
inline void device_to_host_with_callback(T *self, std::size_t block, callback *cb, Args &... args) {
    if ( cb ) {
        cb->pre_device_to_host(block);
    }
    self->device_to_host(args...);
    if ( cb ) {
        cb->post_device_to_host(block);
    }
}


class measure_callback : public callback {
public:
    measure_callback() :
        compute_time(),
        transport_time(),
        compute_ctx(nullptr),
        transport_ctx(nullptr)
    {}

    void initialize(std::size_t total, std::size_t count) override {}
    void finalize() override {}

    void pre_compute(std::size_t block) override {
        this->compute_ctx = this->compute_time.create_context();
    }
    void post_compute(std::size_t block) override {
        this->compute_ctx.done();
    }

    void pre_host_to_device(std::size_t block) override {
        this->pre_transport();
    }
    void post_host_to_device(std::size_t block) override {
        this->post_transport();
    }

    void pre_device_to_host(std::size_t block) override {
        this->pre_transport();
    }
    void post_device_to_host(std::size_t block) override {
        this->post_transport();
    }

    time::measure compute_time;
    time::measure transport_time;


    void print_timestamp() const {
        auto p = std::chrono::system_clock::now();
        auto t = std::chrono::system_clock::to_time_t(p);
        auto lt = std::localtime(&t);
        std::cout << std::put_time(lt, "%FT%T") << std::endl;
    }

    void print_measure_report() const {
        auto t = this->transport_time.time / 1000.0;
        auto c = this->compute_time.time / 1000.0;
        std::cout << "total: " << (t + c) << "msec; compute: " << c << "msec transport: " << t << "msec." << std::endl;
    }

    void measure_reset() {
        this->transport_time.time = 0;
        this->compute_time.time = 0;
    }

protected:
    virtual void pre_transport() {
        this->transport_ctx = this->transport_time.create_context();
    }
    virtual void post_transport() {
        this->transport_ctx.done();
    }

    time::measure::context compute_ctx;
    time::measure::context transport_ctx;

};

} // namespace utility


namespace impl {

namespace interface {

template <class T, class Sink, class Operator>
class abstract {
public:
    typedef Sink sink_t;

    abstract(boost::compute::context context,
             boost::compute::command_queue queue,
             const std::size_t device_size) :
        context(context),
        queue(queue),
        device_size(device_size)
    {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().do_compute(
                    std::declval<Operator>(),
                    std::declval<std::size_t>()
                )),
                void>::value,
            "void T::do_compute(Operator, std::size_t) is not defined."
        );
        static_assert(
            std::is_same<
                decltype(std::declval<T>().device_to_host(
                    std::declval<sink_t &>(),
                    std::declval<std::size_t>()
                )),
                void>::value,
            "void T::device_to_host(sink_t &, std::size_t) is not defined."
        );
    }

    virtual ~abstract() {}

public:
    void do_compute(Operator op) {
        this->do_compute(op, this->device_size);
    }
    void do_compute(Operator op, const std::size_t size) {
        static_cast<T *>(this)->do_compute(op, size);
    }

    void device_to_host(sink_t &snk) {
        this->device_to_host(snk, this->device_size);
    }
    void device_to_host(sink_t &snk, std::size_t size) {
        static_cast<T *>(this)->device_to_host(snk, size);
    }


protected:
    boost::compute::context context;
    boost::compute::command_queue queue;

    std::size_t device_size;

};

template <class T, class Source, class Sink, class UnaryOperator>
class unary : public abstract<T, Sink, UnaryOperator> {
public:
    typedef Source source_t;
    typedef Sink sink_t;

    using abstract<T, Sink, UnaryOperator>::abstract;

    void compute(source_t &src, sink_t &snk, UnaryOperator op, utility::callback *cb) {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().compute(
                    std::declval<source_t &>(),
                    std::declval<sink_t &>(),
                    std::declval<UnaryOperator>(),
                    std::declval<utility::callback *>()
                )),
                void>::value,
            "void T::compute(source_t &, sink_t &, UnaryOperator, callback *) is not defined."
        );
        static_cast<T *>(this)->compute(src, snk, op);
    }

public:
    void host_to_device(source_t &src) {
        this->host_to_device(src, this->device_size);
    }
    void host_to_device(source_t &src, std::size_t size) {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().host_to_device(
                    std::declval<source_t>(),
                    std::declval<std::size_t>()
                )),
                void>::value,
            "void T::host_to_device(source_t &, std::size_t) is not defined."
        );
        static_cast<T *>(this)->host_to_device(src, size);
    }

};

template <class T, class Source1, class Source2, class Sink, class BinaryOperator>
class binary : public abstract<T, Sink, BinaryOperator> {
public:
    typedef Source1 source1_t;
    typedef Source2 source2_t;
    typedef Sink sink_t;

    using abstract<T, Sink, BinaryOperator>::abstract;

    void compute(source1_t &src1, source2_t &src2, sink_t &snk, BinaryOperator op, utility::callback *cb) {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().compute(
                    std::declval<source1_t &>(),
                    std::declval<source2_t &>(),
                    std::declval<sink_t &>(),
                    std::declval<BinaryOperator>(),
                    std::declval<utility::callback *>()
                )),
                void>::value,
            "void T::compute(source1_t &, source2_t &, sink_t &, BinaryOperator, callback *) is not defined."
        );
        static_cast<T *>(this)->compute(src1, src2, snk, op);
    }

public:
    void host_to_device(source1_t &src1, source2_t &src2) {
        this->host_to_device(src1, src2, this->device_size);
    }
    void host_to_device(source1_t &src1, source2_t &src2, std::size_t size) {
        static_assert(
            std::is_same<
                decltype(std::declval<T>().host_to_device(
                    std::declval<source1_t &>(),
                    std::declval<source2_t &>(),
                    std::declval<std::size_t>()
                )),
                void>::value,
            "void T::host_to_device(source1_t &, source2_t &, std::size_t) is not defined."
        );
        static_cast<T *>(this)->host_to_device(src1, src2, size);
    }

};

} // namespace interface

} // namespace impl


namespace linear {

namespace impl {

template <class T, class Source, class Sink, class UnaryOperator>
class unary_interface : public sep::compute::impl::interface::unary<T, Source, Sink, UnaryOperator> {
public:
    typedef Source source_t;
    typedef Sink sink_t;

    using sep::compute::impl::interface::unary<T, Source, Sink, UnaryOperator>::unary;

    typedef std::vector<typename source_t::type> ihost_t;
    typedef std::vector<typename sink_t::type> ohost_t;
    typedef boost::compute::vector<typename source_t::type> idevice_t;
    typedef boost::compute::vector<typename sink_t::type> odevice_t;

    void compute(source_t &src, sink_t &snk, UnaryOperator op, utility::callback *cb=nullptr) {
        std::size_t total = src.total();
        std::size_t loop = total / this->device_size;
        std::size_t remain = total % this->device_size;
        utility::initialize_callback(cb, total, loop + ((remain > 0) ? 1 : 0));
        for (std::size_t i = 0; i < loop; ++i) {
            // host to device
            utility::host_to_device_with_callback(this, i, cb, src);
            // compute
            utility::compute_with_callback(this, i, cb, op);
            // device to host
            utility::device_to_host_with_callback(this, i, cb, snk);
        }
        // remain
        if ( remain > 0 ) {
            // host to device
            utility::host_to_device_with_callback(this, loop, cb, src, remain);
            // compute
            utility::compute_with_callback(this, loop, cb, op, remain);
            // device to host
            utility::device_to_host_with_callback(this, loop, cb, snk, remain);
        }
        utility::finalize_callback(cb);
    }

};


template <class T, class Source1, class Source2, class Sink, class BinaryOperator>
class binary_interface : public sep::compute::impl::interface::binary<T, Source1, Source2, Sink, BinaryOperator> {
public:
    typedef Source1 source1_t;
    typedef Source2 source2_t;
    typedef Sink sink_t;

    using sep::compute::impl::interface::binary<T, Source1, Source2, Sink, BinaryOperator>::binary;

    typedef std::vector<typename source1_t::type> ihost1_t;
    typedef std::vector<typename source2_t::type> ihost2_t;
    typedef std::vector<typename sink_t::type> ohost_t;
    typedef boost::compute::vector<typename source1_t::type> idevice1_t;
    typedef boost::compute::vector<typename source2_t::type> idevice2_t;
    typedef boost::compute::vector<typename sink_t::type> odevice_t;

    void compute(source1_t &src1, source2_t &src2, sink_t &snk, BinaryOperator op, utility::callback *cb=nullptr) {
        std::size_t total = src1.total();
        assert(total == src2.total());
        std::size_t loop = total / this->device_size;
        std::size_t remain = total % this->device_size;
        utility::initialize_callback(cb, total, loop + ((remain > 0) ? 1 : 0));
        for (std::size_t i = 0; i < loop; ++i) {
            // host to device
            utility::host_to_device_with_callback(this, i, cb, src1, src2);
            // compute
            utility::compute_with_callback(this, i, cb, op);
            // device to host
            utility::device_to_host_with_callback(this, i, cb, snk);
        }
        // remain
        if ( remain > 0 ) {
            // host to device
            utility::host_to_device_with_callback(this, loop, cb, src1, src2, remain);
            // compute
            utility::compute_with_callback(this, loop, cb, op, remain);
            // device to host
            utility::device_to_host_with_callback(this, loop, cb, snk, remain);
        }
        utility::finalize_callback(cb);
    }

};

} // namespace impl


template <class Source, class Sink, class UnaryOperator>
class inplace : public impl::unary_interface<inplace<Source, Sink, UnaryOperator>, Source, Sink, UnaryOperator> {
public:
    typedef impl::unary_interface<inplace<Source, Sink, UnaryOperator>, Source, Sink, UnaryOperator> BaseClass;

    typedef Source source_t;
    typedef Sink sink_t;
    typedef std::vector<typename source_t::type> ihost_t;
    typedef boost::compute::vector<typename source_t::type> idevice_t;

    inplace(boost::compute::context context,
            boost::compute::command_queue queue,
            const std::size_t device_size) :
        BaseClass(context, queue, device_size),
        host(this->device_size),
        device(this->device_size, context)
    {}

public:
    void do_compute(UnaryOperator op, const std::size_t size) {
        boost::compute::transform(
            this->device.begin(),
            this->device.begin() + size,
            this->device.begin(),
            op,
            this->queue
        );
    }

    void host_to_device(source_t &src, std::size_t size) {
        std::size_t loaded = src.read(this->host, size);
        assert(loaded == size);
        boost::compute::copy(
            this->host.begin(),
            this->host.begin() + size,
            this->device.begin(),
            this->queue
        );
    }

    void device_to_host(sink_t &snk, std::size_t size) {
        boost::compute::copy(
            this->device.begin(),
            this->device.begin() + size,
            this->host.begin(),
            this->queue
        );
        snk.write(this->host, size);
    }

public:
    static_assert(std::is_same<typename source_t::type, typename sink_t::type>::value, "Source::type and Sink::type is not same.");

    ihost_t host;
    idevice_t device;

};


template <class Source, class Sink, class UnaryOperator>
class unary : public impl::unary_interface<unary<Source, Sink, UnaryOperator>, Source, Sink, UnaryOperator> {
public:
    typedef impl::unary_interface<unary<Source, Sink, UnaryOperator>, Source, Sink, UnaryOperator> BaseClass;

    typedef Source source_t;
    typedef Sink sink_t;

    typedef std::vector<typename source_t::type> ihost_t;
    typedef std::vector<typename sink_t::type> ohost_t;
    typedef boost::compute::vector<typename source_t::type> idevice_t;
    typedef boost::compute::vector<typename sink_t::type> odevice_t;

    unary(boost::compute::context context,
          boost::compute::command_queue queue,
          const std::size_t device_size) :
        BaseClass(context, queue, device_size),
        ihost(this->device_size),
        ohost(this->device_size),
        idevice(this->device_size, context),
        odevice(this->device_size, context)
    {}

public:
    void do_compute(UnaryOperator op, const std::size_t size) {
        boost::compute::transform(
            this->idevice.begin(),
            this->idevice.begin() + size,
            this->odevice.begin(),
            op,
            this->queue
        );
    }

    void host_to_device(source_t &src, std::size_t size) {
        std::size_t loaded = src.read(this->ihost, size);
        assert(loaded == size);
        boost::compute::copy(
            this->ihost.begin(),
            this->ihost.begin() + size,
            this->idevice.begin(),
            this->queue
        );
    }

    void device_to_host(sink_t &snk, std::size_t size) {
        boost::compute::copy(
            this->odevice.begin(),
            this->odevice.begin() + size,
            this->ohost.begin(),
            this->queue
        );
        snk.write(this->ohost, size);
    }

protected:
    ihost_t ihost;
    ohost_t ohost;
    idevice_t idevice;
    odevice_t odevice;

};


template <class Source1, class Source2, class Sink, class BinaryOperator>
class binary : public impl::binary_interface<binary<Source1, Source2, Sink, BinaryOperator>, Source1, Source2, Sink, BinaryOperator> {
public:
    typedef impl::binary_interface<binary<Source1, Source2, Sink, BinaryOperator>, Source1, Source2, Sink, BinaryOperator> BaseClass;

    typedef Source1 source1_t;
    typedef Source2 source2_t;
    typedef Sink sink_t;

    typedef std::vector<typename source1_t::type> ihost1_t;
    typedef std::vector<typename source2_t::type> ihost2_t;
    typedef std::vector<typename sink_t::type> ohost_t;
    typedef boost::compute::vector<typename source1_t::type> idevice1_t;
    typedef boost::compute::vector<typename source2_t::type> idevice2_t;
    typedef boost::compute::vector<typename sink_t::type> odevice_t;

    binary(boost::compute::context context,
           boost::compute::command_queue queue,
           const std::size_t device_size) :
        BaseClass(context, queue, device_size),
        ihost1(this->device_size),
        ihost2(this->device_size),
        ohost(this->device_size),
        idevice1(this->device_size, context),
        idevice2(this->device_size, context),
        odevice(this->device_size, context)
    {}

public:
    void do_compute(BinaryOperator op, const std::size_t size) {
        boost::compute::transform(
            this->idevice1.begin(),
            this->idevice1.begin() + size,
            this->idevice2.begin(),
            this->odevice.begin(),
            op,
            this->queue
        );
    }

    void host_to_device(source1_t &src1, source2_t &src2, std::size_t size) {
        std::size_t read1 = src1.read(this->ihost1, size);
        std::size_t read2 = src2.read(this->ihost2, size);
        assert(read1 == size && read2 == size);
        auto do_copy = [this, size](auto &host, auto &device){
            boost::compute::copy(
                host.begin(),
                host.begin() + size,
                device.begin(),
                this->queue
            );
        };
        do_copy(this->ihost1, this->idevice1);
        do_copy(this->ihost2, this->idevice2);
    }

    void device_to_host(sink_t &snk, std::size_t size) {
        boost::compute::copy(
            this->odevice.begin(),
            this->odevice.begin() + size,
            this->ohost.begin(),
            this->queue
        );
        snk.write(this->ohost, size);
    }

protected:
    ihost1_t ihost1;
    ihost2_t ihost2;
    ohost_t ohost;
    idevice1_t idevice1;
    idevice2_t idevice2;
    odevice_t odevice;

};


class manager {
public:
    manager(boost::compute::context context,
            boost::compute::command_queue queue,
            std::size_t max_memory) :
        context(context),
        queue(queue),
        max_memory(max_memory)
    {}

    template <class Source, class Sink>
    static constexpr std::size_t inplace_size(const std::size_t max_memory) {
        static_assert(std::is_same<typename Source::type, typename Sink::type>::value, "Source::type != Sink::type");
        return max_memory / Source::type_bytes;
    }

    template <class Source, class Sink>
    static constexpr std::size_t unary_size(const std::size_t max_memory) {
        return max_memory / (Source::type_bytes + Sink::type_bytes);
    }

    template <class Source1, class Source2, class Sink>
    static constexpr std::size_t binary_size(const std::size_t max_memory) {
        return max_memory / (Source1::type_bytes + Source2::type_bytes + Sink::type_bytes);
    }


    template <class Source, class Sink, class UnaryOperator>
    inline void inplace(Source &src, Sink &snk, UnaryOperator op, utility::callback *cb=nullptr) {
        typedef sep::compute::linear::inplace<Source, Sink, UnaryOperator> Class;
        std::size_t size = inplace_size<Source, Sink>(this->max_memory);
        Class(this->context, this->queue, size).compute(src, snk, op, cb);
    }

    template <class Source, class Sink, class UnaryOperator>
    inline void compute(Source &src, Sink &snk, UnaryOperator op, utility::callback *cb=nullptr) {
        typedef sep::compute::linear::unary<Source, Sink, UnaryOperator> Class;
        std::size_t size = unary_size<Source, Sink>(this->max_memory);
        Class(this->context, this->queue, size).compute(src, snk, op, cb);
    }

    template <class Source1, class Source2, class Sink, class BinaryOperator>
    inline void compute(Source1 &src1, Source2 &src2, Sink &snk, BinaryOperator op, utility::callback *cb=nullptr) {
        typedef sep::compute::linear::binary<Source1, Source2, Sink, BinaryOperator> Class;
        std::size_t size = binary_size<Source1, Source2, Sink>(this->max_memory);
        Class(this->context, this->queue, size).compute(src1, src2, snk, op, cb);
    }

protected:
    boost::compute::context context;
    boost::compute::command_queue queue;
    std::size_t max_memory;

};


} // namespace linear

} // namespace compute

} // namespace sep

#endif // LARGE_SOURCE_COMPUTE_HPP
